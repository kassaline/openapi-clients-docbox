<?php
/**
 * ExtendedDocument
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client\Docbox
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * DOCBOX® API
 *
 * The DOCBOX® REST API makes it possible to integrate the DOCBOX® into third-party programs such as ERP or CRM applications. The third-party programs can access certain DOCBOX® functions, for example to archive documents in the DOCBOX® or to search for documents in it.  The api is available under https://{docbox-host}:{api-port}/api/v2. The default port is 8081 and should not be mistaken with the port of the webapp.  To authenticate to the API you must pass the API-Key header. Api keys can be configured by administrators in the modules->API section. If you are using the cloud version of DOCBOX® you must also pass the Cloud-ID header with your Cloudid.
 *
 * The version of the OpenAPI document: 7.6.0
 * Contact: support@docbox.eu
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.5.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Docbox\Model;

use \ArrayAccess;
use \OpenAPI\Client\Docbox\ObjectSerializer;

/**
 * ExtendedDocument Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client\Docbox
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ExtendedDocument implements ModelInterface, ArrayAccess, \JsonSerializable, \Stringable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'extendedDocument';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'int',
        'name' => 'string',
        'numPages' => 'int',
        'mandator' => 'string',
        'folderId' => 'int',
        'folderPath' => 'string',
        'creationDate' => '\DateTime',
        'creatorId' => 'int',
        'creatorName' => 'string',
        'keywords' => 'string[]',
        'classification' => 'string[]',
        'external' => \OpenAPI\Client\Docbox\Model\ExtendedDocumentExternal::class,
        'workflows' => '\OpenAPI\Client\Docbox\Model\ExtendedDocumentWorkflowsInner[]',
        'pages' => '\OpenAPI\Client\Docbox\Model\DocumentPage[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => 'int64',
        'name' => null,
        'numPages' => null,
        'mandator' => null,
        'folderId' => 'int64',
        'folderPath' => null,
        'creationDate' => 'date-time',
        'creatorId' => 'int64',
        'creatorName' => null,
        'keywords' => null,
        'classification' => null,
        'external' => null,
        'workflows' => null,
        'pages' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'name' => false,
        'numPages' => false,
        'mandator' => false,
        'folderId' => false,
        'folderPath' => false,
        'creationDate' => false,
        'creatorId' => false,
        'creatorName' => false,
        'keywords' => false,
        'classification' => false,
        'external' => false,
        'workflows' => false,
        'pages' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Checks if a property is nullable
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->openAPINullablesSetToNull, true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'name' => 'name',
        'numPages' => 'numPages',
        'mandator' => 'mandator',
        'folderId' => 'folderId',
        'folderPath' => 'folderPath',
        'creationDate' => 'creationDate',
        'creatorId' => 'creatorId',
        'creatorName' => 'creatorName',
        'keywords' => 'keywords',
        'classification' => 'classification',
        'external' => 'external',
        'workflows' => 'workflows',
        'pages' => 'pages'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'name' => 'setName',
        'numPages' => 'setNumPages',
        'mandator' => 'setMandator',
        'folderId' => 'setFolderId',
        'folderPath' => 'setFolderPath',
        'creationDate' => 'setCreationDate',
        'creatorId' => 'setCreatorId',
        'creatorName' => 'setCreatorName',
        'keywords' => 'setKeywords',
        'classification' => 'setClassification',
        'external' => 'setExternal',
        'workflows' => 'setWorkflows',
        'pages' => 'setPages'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'name' => 'getName',
        'numPages' => 'getNumPages',
        'mandator' => 'getMandator',
        'folderId' => 'getFolderId',
        'folderPath' => 'getFolderPath',
        'creationDate' => 'getCreationDate',
        'creatorId' => 'getCreatorId',
        'creatorName' => 'getCreatorName',
        'keywords' => 'getKeywords',
        'classification' => 'getClassification',
        'external' => 'getExternal',
        'workflows' => 'getWorkflows',
        'pages' => 'getPages'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('numPages', $data ?? [], null);
        $this->setIfExists('mandator', $data ?? [], null);
        $this->setIfExists('folderId', $data ?? [], null);
        $this->setIfExists('folderPath', $data ?? [], null);
        $this->setIfExists('creationDate', $data ?? [], null);
        $this->setIfExists('creatorId', $data ?? [], null);
        $this->setIfExists('creatorName', $data ?? [], null);
        $this->setIfExists('keywords', $data ?? [], null);
        $this->setIfExists('classification', $data ?? [], null);
        $this->setIfExists('external', $data ?? [], null);
        $this->setIfExists('workflows', $data ?? [], null);
        $this->setIfExists('pages', $data ?? [], null);
    }

    /**
     * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
     * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
     * $this->openAPINullablesSetToNull array
     */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        return [];
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return $this->listInvalidProperties() === [];
    }


    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id id
     */
    public function setId($id): self
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }

        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string|null
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string|null $name name
     */
    public function setName($name): self
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }

        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets numPages
     *
     * @return int|null
     */
    public function getNumPages()
    {
        return $this->container['numPages'];
    }

    /**
     * Sets numPages
     *
     * @param int|null $numPages numPages
     */
    public function setNumPages($numPages): self
    {
        if (is_null($numPages)) {
            throw new \InvalidArgumentException('non-nullable numPages cannot be null');
        }

        $this->container['numPages'] = $numPages;

        return $this;
    }

    /**
     * Gets mandator
     *
     * @return string|null
     */
    public function getMandator()
    {
        return $this->container['mandator'];
    }

    /**
     * Sets mandator
     *
     * @param string|null $mandator mandator
     */
    public function setMandator($mandator): self
    {
        if (is_null($mandator)) {
            throw new \InvalidArgumentException('non-nullable mandator cannot be null');
        }

        $this->container['mandator'] = $mandator;

        return $this;
    }

    /**
     * Gets folderId
     *
     * @return int|null
     */
    public function getFolderId()
    {
        return $this->container['folderId'];
    }

    /**
     * Sets folderId
     *
     * @param int|null $folderId folderId
     */
    public function setFolderId($folderId): self
    {
        if (is_null($folderId)) {
            throw new \InvalidArgumentException('non-nullable folderId cannot be null');
        }

        $this->container['folderId'] = $folderId;

        return $this;
    }

    /**
     * Gets folderPath
     *
     * @return string|null
     */
    public function getFolderPath()
    {
        return $this->container['folderPath'];
    }

    /**
     * Sets folderPath
     *
     * @param string|null $folderPath folderPath
     */
    public function setFolderPath($folderPath): self
    {
        if (is_null($folderPath)) {
            throw new \InvalidArgumentException('non-nullable folderPath cannot be null');
        }

        $this->container['folderPath'] = $folderPath;

        return $this;
    }

    /**
     * Gets creationDate
     *
     * @return \DateTime|null
     */
    public function getCreationDate()
    {
        return $this->container['creationDate'];
    }

    /**
     * Sets creationDate
     *
     * @param \DateTime|null $creationDate creationDate
     */
    public function setCreationDate($creationDate): self
    {
        if (is_null($creationDate)) {
            throw new \InvalidArgumentException('non-nullable creationDate cannot be null');
        }

        $this->container['creationDate'] = $creationDate;

        return $this;
    }

    /**
     * Gets creatorId
     *
     * @return int|null
     */
    public function getCreatorId()
    {
        return $this->container['creatorId'];
    }

    /**
     * Sets creatorId
     *
     * @param int|null $creatorId creatorId
     */
    public function setCreatorId($creatorId): self
    {
        if (is_null($creatorId)) {
            throw new \InvalidArgumentException('non-nullable creatorId cannot be null');
        }

        $this->container['creatorId'] = $creatorId;

        return $this;
    }

    /**
     * Gets creatorName
     *
     * @return string|null
     */
    public function getCreatorName()
    {
        return $this->container['creatorName'];
    }

    /**
     * Sets creatorName
     *
     * @param string|null $creatorName creatorName
     */
    public function setCreatorName($creatorName): self
    {
        if (is_null($creatorName)) {
            throw new \InvalidArgumentException('non-nullable creatorName cannot be null');
        }

        $this->container['creatorName'] = $creatorName;

        return $this;
    }

    /**
     * Gets keywords
     *
     * @return string[]|null
     */
    public function getKeywords()
    {
        return $this->container['keywords'];
    }

    /**
     * Sets keywords
     *
     * @param string[]|null $keywords keywords
     */
    public function setKeywords($keywords): self
    {
        if (is_null($keywords)) {
            throw new \InvalidArgumentException('non-nullable keywords cannot be null');
        }

        $this->container['keywords'] = $keywords;

        return $this;
    }

    /**
     * Gets classification
     *
     * @return string[]|null
     */
    public function getClassification()
    {
        return $this->container['classification'];
    }

    /**
     * Sets classification
     *
     * @param string[]|null $classification classification
     */
    public function setClassification($classification): self
    {
        if (is_null($classification)) {
            throw new \InvalidArgumentException('non-nullable classification cannot be null');
        }

        $this->container['classification'] = $classification;

        return $this;
    }

    /**
     * Gets external
     *
     * @return \OpenAPI\Client\Docbox\Model\ExtendedDocumentExternal|null
     */
    public function getExternal()
    {
        return $this->container['external'];
    }

    /**
     * Sets external
     *
     * @param \OpenAPI\Client\Docbox\Model\ExtendedDocumentExternal|null $external external
     */
    public function setExternal($external): self
    {
        if (is_null($external)) {
            throw new \InvalidArgumentException('non-nullable external cannot be null');
        }

        $this->container['external'] = $external;

        return $this;
    }

    /**
     * Gets workflows
     *
     * @return \OpenAPI\Client\Docbox\Model\ExtendedDocumentWorkflowsInner[]|null
     */
    public function getWorkflows()
    {
        return $this->container['workflows'];
    }

    /**
     * Sets workflows
     *
     * @param \OpenAPI\Client\Docbox\Model\ExtendedDocumentWorkflowsInner[]|null $workflows workflows
     */
    public function setWorkflows($workflows): self
    {
        if (is_null($workflows)) {
            throw new \InvalidArgumentException('non-nullable workflows cannot be null');
        }

        $this->container['workflows'] = $workflows;

        return $this;
    }

    /**
     * Gets pages
     *
     * @return \OpenAPI\Client\Docbox\Model\DocumentPage[]|null
     */
    public function getPages()
    {
        return $this->container['pages'];
    }

    /**
     * Sets pages
     *
     * @param \OpenAPI\Client\Docbox\Model\DocumentPage[]|null $pages pages
     */
    public function setPages($pages): self
    {
        if (is_null($pages)) {
            throw new \InvalidArgumentException('non-nullable pages cannot be null');
        }

        $this->container['pages'] = $pages;

        return $this;
    }

    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     */
    public function offsetSet($offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     */
    public function __toString(): string
    {
        return (string) json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


